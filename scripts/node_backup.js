#!/usr/bin/env node

/**
 * =================================================================
 * SUPABASE VERƒ∞TABANI YEDEKLEme SCRƒ∞PTƒ∞ (Node.js)
 * =================================================================
 * Bu script PostgreSQL client tools olmadan √ßalƒ±≈üƒ±r
 * Supabase API kullanarak veritabanƒ±nƒ± yedekler
 * =================================================================
 */

const fs = require('fs');
const path = require('path');
const { createClient } = require('@supabase/supabase-js');
require('dotenv').config({ path: '.env.local' });

// Renk kodlarƒ±
const colors = {
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    reset: '\x1b[0m'
};

function log(color, message) {
    console.log(`${colors[color]}${message}${colors.reset}`);
}

async function main() {
    log('blue', '='.repeat(65));
    log('blue', '       SUPABASE VERƒ∞TABANI YEDEKLEme SCRƒ∞PTƒ∞ (Node.js)');
    log('blue', '='.repeat(65));

    // Environment variables kontrol
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

    if (!supabaseUrl || !supabaseKey) {
        log('red', '‚ùå .env.local dosyasƒ±nda gerekli deƒüi≈ükenler eksik!');
        log('yellow', 'Gerekli deƒüi≈ükenler:');
        log('yellow', '  NEXT_PUBLIC_SUPABASE_URL');
        log('yellow', '  SUPABASE_SERVICE_ROLE_KEY');
        process.exit(1);
    }

    // Supabase client olu≈ütur
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Backup klas√∂r√º olu≈ütur
    const backupDir = './database_backups';
    if (!fs.existsSync(backupDir)) {
        fs.mkdirSync(backupDir, { recursive: true });
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0] + '_' + 
                     new Date().toISOString().replace(/[:.]/g, '-').split('T')[1].split('-')[0];

    log('yellow', `üìÅ Yedek klas√∂r√º: ${backupDir}`);

    try {
        // T√ºm tablolarƒ± listele
        log('blue', 'üîç Tablolar listeleniyor...');
        
        const { data: tables, error: tablesError } = await supabase
            .rpc('get_table_list');

        if (tablesError) {
            // Fallback: Manuel tablo listesi
            const tableList = [
                'admin_kullanicilar',
                'alanlar', 
                'belgeler',
                'dekontlar',
                'gorev_belgeleri',
                'isletmeler',
                'notifications',
                'ogretmenler',
                'siniflar',
                'stajyerler',
                'system_settings'
            ];
            
            log('yellow', '‚ö†Ô∏è  RPC kullanƒ±lamƒ±yor, manuel tablo listesi kullanƒ±lƒ±yor');
            await backupTables(supabase, tableList, backupDir, timestamp);
        } else {
            await backupTables(supabase, tables, backupDir, timestamp);
        }

        // Schema backup
        await backupSchema(supabase, backupDir, timestamp);

        log('green', '='.repeat(65));
        log('green', 'üéâ YEDEKLEme ƒ∞≈ûLEMƒ∞ BA≈ûARIYLA TAMAMLANDI!');
        log('green', '='.repeat(65));
        log('yellow', `üìÅ Yedek konumu: ${backupDir}`);
        log('yellow', `üìÖ Yedek tarihi: ${timestamp}`);

    } catch (error) {
        log('red', `‚ùå Hata: ${error.message}`);
        process.exit(1);
    }
}

async function backupTables(supabase, tableList, backupDir, timestamp) {
    const backupData = {};
    
    log('blue', `üìä ${tableList.length} tablo yedekleniyor...`);

    for (const tableName of tableList) {
        try {
            log('yellow', `  üìã ${tableName} tablosu yedekleniyor...`);
            
            const { data, error } = await supabase
                .from(tableName)
                .select('*');

            if (error) {
                log('red', `    ‚ùå ${tableName} hatasƒ±: ${error.message}`);
                continue;
            }

            backupData[tableName] = {
                table_name: tableName,
                row_count: data ? data.length : 0,
                data: data || []
            };

            log('green', `    ‚úÖ ${tableName}: ${data ? data.length : 0} kayƒ±t`);

        } catch (error) {
            log('red', `    ‚ùå ${tableName} hatasƒ±: ${error.message}`);
        }
    }

    // JSON olarak kaydet
    const dataBackupFile = path.join(backupDir, `data_backup_${timestamp}.json`);
    fs.writeFileSync(dataBackupFile, JSON.stringify(backupData, null, 2));
    log('green', `‚úÖ Veri yedeƒüi tamamlandƒ±: ${dataBackupFile}`);

    // SQL INSERT formatƒ±nda kaydet
    const sqlBackupFile = path.join(backupDir, `data_backup_${timestamp}.sql`);
    let sqlContent = `-- Supabase Veri Yedeƒüi\n-- Tarih: ${new Date().toISOString()}\n\n`;
    
    for (const [tableName, tableData] of Object.entries(backupData)) {
        if (tableData.data && tableData.data.length > 0) {
            sqlContent += `-- ${tableName} tablosu (${tableData.row_count} kayƒ±t)\n`;
            sqlContent += `TRUNCATE ${tableName} CASCADE;\n`;
            
            // INSERT statements olu≈ütur
            for (const row of tableData.data) {
                const columns = Object.keys(row).join(', ');
                const values = Object.values(row).map(val => {
                    if (val === null) return 'NULL';
                    if (typeof val === 'string') return `'${val.replace(/'/g, "''")}'`;
                    if (typeof val === 'boolean') return val;
                    if (typeof val === 'object') return `'${JSON.stringify(val).replace(/'/g, "''")}'`;
                    return val;
                }).join(', ');
                
                sqlContent += `INSERT INTO ${tableName} (${columns}) VALUES (${values});\n`;
            }
            sqlContent += '\n';
        }
    }

    fs.writeFileSync(sqlBackupFile, sqlContent);
    log('green', `‚úÖ SQL yedeƒüi tamamlandƒ±: ${sqlBackupFile}`);
}

async function backupSchema(supabase, backupDir, timestamp) {
    try {
        log('blue', 'üìã Kapsamlƒ± schema bilgileri yedekleniyor...');

        const schemaInfo = {
            timestamp: new Date().toISOString(),
            tables: {},
            functions: [],
            triggers: [],
            indexes: [],
            policies: []
        };

        // Functions yedekleme
        await backupFunctions(supabase, schemaInfo);
        
        // Triggers yedekleme
        await backupTriggers(supabase, schemaInfo);
        
        // Indexes yedekleme
        await backupIndexes(supabase, schemaInfo);
        
        // RLS Policies yedekleme
        await backupPolicies(supabase, schemaInfo);

        const schemaFile = path.join(backupDir, `schema_backup_${timestamp}.json`);
        fs.writeFileSync(schemaFile, JSON.stringify(schemaInfo, null, 2));
        log('green', `‚úÖ Kapsamlƒ± schema yedeƒüi tamamlandƒ±: ${schemaFile}`);

        // SQL format schema backup
        await createSchemaSQL(schemaInfo, backupDir, timestamp);

    } catch (error) {
        log('yellow', `‚ö†Ô∏è  Schema yedekleme hatasƒ±: ${error.message}`);
    }
}

async function backupFunctions(supabase, schemaInfo) {
    try {
        log('yellow', '  üîß Functions yedekleniyor...');
        
        // Information schema kullanarak functions alma
        const { data: functions, error } = await supabase
            .from('information_schema.routines')
            .select('*')
            .eq('routine_schema', 'public')
            .neq('routine_name', 'like')
            .not('routine_name', 'like', 'pg_%');

        if (!error && functions && functions.length > 0) {
            schemaInfo.functions = functions;
            log('green', `    ‚úÖ ${functions.length} function yedeklendi`);
        } else {
            // Alternatif: Manuel function listesi
            const knownFunctions = [
                'check_isletme_pin_giris',
                'check_ogretmen_pin_giris',
                'update_system_setting',
                'get_system_setting',
                'get_admin_users',
                'create_admin_user',
                'update_admin_user',
                'delete_admin_user',
                'is_user_admin',
                'get_gorev_belgeleri_detayli',
                'prevent_super_admin_deactivation',
                'update_dekont_onay_tarihi',
                'set_default_dekont_values',
                'set_default_odeme_son_tarihi'
            ];
            
            schemaInfo.functions = knownFunctions.map(name => ({
                function_name: name,
                status: 'known_function',
                source: 'scripts/'
            }));
            
            log('green', `    ‚úÖ ${knownFunctions.length} bilinen function listelendi`);
        }
    } catch (error) {
        schemaInfo.functions = [];
        log('yellow', `    ‚ö†Ô∏è  Functions yedekleme hatasƒ±: ${error.message}`);
    }
}

async function backupTriggers(supabase, schemaInfo) {
    try {
        log('yellow', '  ‚ö° Triggers yedekleniyor...');
        
        // Bilinen trigger'lar listesi (scripts klas√∂r√ºnden)
        const knownTriggers = [
            {
                trigger_name: 'dekont_onay_durumu_degistiginde',
                table_name: 'dekontlar',
                function_name: 'update_dekont_onay_tarihi',
                description: 'Dekont onay durumu deƒüi≈ütiƒüinde otomatik tarih g√ºncelleme'
            },
            {
                trigger_name: 'tr_set_default_dekont_values',
                table_name: 'dekontlar',
                function_name: 'set_default_dekont_values',
                description: 'Dekont ekleme/g√ºncelleme sƒ±rasƒ±nda varsayƒ±lan deƒüerleri ayarlama'
            },
            {
                trigger_name: 'tr_set_default_odeme_son_tarihi',
                table_name: 'dekontlar',
                function_name: 'set_default_odeme_son_tarihi',
                description: '√ñdeme son tarihi otomatik hesaplama'
            },
            {
                trigger_name: 'protect_super_admin_status',
                table_name: 'admin_kullanicilar',
                function_name: 'prevent_super_admin_deactivation',
                description: 'Super admin deaktivasyonunu engelleme'
            }
        ];
        
        schemaInfo.triggers = knownTriggers;
        log('green', `    ‚úÖ ${knownTriggers.length} bilinen trigger listelendi`);
        
    } catch (error) {
        schemaInfo.triggers = [];
        log('yellow', `    ‚ö†Ô∏è  Triggers yedekleme hatasƒ±: ${error.message}`);
    }
}

async function backupIndexes(supabase, schemaInfo) {
    try {
        log('yellow', '  üìä Indexes yedekleniyor...');
        
        // Bilinen index'ler listesi (scripts klas√∂r√ºnden)
        const knownIndexes = [
            {
                index_name: 'idx_dekontlar_ogrenci',
                table_name: 'dekontlar',
                columns: ['ogrenci_id'],
                description: 'Dekontlar tablosu √∂ƒürenci performans index\'i'
            },
            {
                index_name: 'idx_dekontlar_isletme',
                table_name: 'dekontlar',
                columns: ['isletme_id'],
                description: 'Dekontlar tablosu i≈ületme performans index\'i'
            },
            {
                index_name: 'idx_dekontlar_ay_yil',
                table_name: 'dekontlar',
                columns: ['ay', 'yil'],
                description: 'Dekontlar tablosu tarih performans index\'i'
            },
            {
                index_name: 'idx_dekontlar_onay_durumu',
                table_name: 'dekontlar',
                columns: ['onay_durumu'],
                description: 'Dekontlar tablosu onay durumu performans index\'i'
            }
        ];
        
        schemaInfo.indexes = knownIndexes;
        log('green', `    ‚úÖ ${knownIndexes.length} bilinen index listelendi`);
        
    } catch (error) {
        schemaInfo.indexes = [];
        log('yellow', `    ‚ö†Ô∏è  Indexes yedekleme hatasƒ±: ${error.message}`);
    }
}

async function backupPolicies(supabase, schemaInfo) {
    try {
        log('yellow', '  üîí RLS Policies yedekleniyor...');
        
        // Bilinen RLS policy'ler listesi
        const knownPolicies = [
            {
                policy_name: '√ñƒüretmenler kendi √∂ƒürencilerinin dekontlarƒ±nƒ± g√∂rebilir',
                table_name: 'dekontlar',
                command: 'SELECT',
                description: '√ñƒüretmenler sadece kendi √∂ƒürencilerinin dekontlarƒ±nƒ± g√∂rebilir'
            },
            {
                policy_name: 'ƒ∞≈ületmeler kendi dekontlarƒ±nƒ± g√∂rebilir',
                table_name: 'dekontlar',
                command: 'SELECT',
                description: 'ƒ∞≈ületmeler sadece kendi dekontlarƒ±nƒ± g√∂rebilir'
            },
            {
                policy_name: 'Admin t√ºm dekontlarƒ± g√∂rebilir',
                table_name: 'dekontlar',
                command: 'ALL',
                description: 'Admin kullanƒ±cƒ±larƒ± t√ºm dekontlara eri≈üebilir'
            },
            {
                policy_name: 'System settings admin eri≈üimi',
                table_name: 'system_settings',
                command: 'ALL',
                description: 'Sistem ayarlarƒ±na sadece admin eri≈üimi'
            }
        ];
        
        schemaInfo.policies = knownPolicies;
        log('green', `    ‚úÖ ${knownPolicies.length} bilinen policy listelendi`);
        
    } catch (error) {
        schemaInfo.policies = [];
        log('yellow', `    ‚ö†Ô∏è  Policies yedekleme hatasƒ±: ${error.message}`);
    }
}

async function createSchemaSQL(schemaInfo, backupDir, timestamp) {
    try {
        log('yellow', '  üìÑ Schema SQL dosyasƒ± olu≈üturuluyor...');
        
        let sqlContent = `-- Supabase Schema Yedeƒüi\n-- Tarih: ${new Date().toISOString()}\n\n`;
        
        // Functions
        if (schemaInfo.functions && schemaInfo.functions.length > 0) {
            sqlContent += `-- =============================================================\n`;
            sqlContent += `-- FUNCTIONS (${schemaInfo.functions.length} adet)\n`;
            sqlContent += `-- =============================================================\n\n`;
            
            for (const func of schemaInfo.functions) {
                if (func.function_definition) {
                    sqlContent += `${func.function_definition};\n\n`;
                }
            }
        }
        
        // Triggers
        if (schemaInfo.triggers && schemaInfo.triggers.length > 0) {
            sqlContent += `-- =============================================================\n`;
            sqlContent += `-- TRIGGERS (${schemaInfo.triggers.length} adet)\n`;
            sqlContent += `-- =============================================================\n\n`;
            
            for (const trigger of schemaInfo.triggers) {
                if (trigger.trigger_definition) {
                    sqlContent += `${trigger.trigger_definition};\n\n`;
                }
            }
        }
        
        // Indexes
        if (schemaInfo.indexes && schemaInfo.indexes.length > 0) {
            sqlContent += `-- =============================================================\n`;
            sqlContent += `-- INDEXES (${schemaInfo.indexes.length} adet)\n`;
            sqlContent += `-- =============================================================\n\n`;
            
            for (const index of schemaInfo.indexes) {
                if (index.index_definition) {
                    sqlContent += `${index.index_definition};\n\n`;
                }
            }
        }
        
        const schemaFile = path.join(backupDir, `schema_backup_${timestamp}.sql`);
        fs.writeFileSync(schemaFile, sqlContent);
        log('green', `    ‚úÖ Schema SQL dosyasƒ±: ${schemaFile}`);
        
    } catch (error) {
        log('yellow', `    ‚ö†Ô∏è  Schema SQL olu≈üturma hatasƒ±: ${error.message}`);
    }
}

// Restore talimatlarƒ± olu≈ütur
function createRestoreInstructions(backupDir, timestamp) {
    const instructionsFile = path.join(backupDir, `restore_instructions_${timestamp}.txt`);
    const instructions = `
=================================================================
VERƒ∞TABANI GERƒ∞ Y√úKLEME TALƒ∞MATLARI (Node.js)
=================================================================
Tarih: ${new Date().toISOString()}
Yedek Dosyalarƒ±: ${timestamp}

1. JSON FORMATINDAN GERƒ∞ Y√úKLEME:
   node scripts/node_restore.js data_backup_${timestamp}.json

2. SQL FORMATINDAN GERƒ∞ Y√úKLEME:
   psql -h your-host -p 5432 -U postgres -d postgres -f data_backup_${timestamp}.sql

3. MANUEL GERƒ∞ Y√úKLEME:
   - JSON dosyasƒ±nƒ± a√ßƒ±n
   - Her tablo i√ßin verileri kopyalayƒ±n
   - Supabase Dashboard'dan Table Editor ile yapƒ±≈ütƒ±rƒ±n

UYARI:
- Geri y√ºkleme i≈ülemi √∂ncesinde mevcut verileri yedekleyin
- RLS (Row Level Security) politikalarƒ±nƒ± kontrol edin
- Unique constraint'leri g√∂z √∂n√ºnde bulundurun

=================================================================
`;

    fs.writeFileSync(instructionsFile, instructions);
    log('green', `üìã Restore talimatlarƒ± olu≈üturuldu: ${instructionsFile}`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = { main };