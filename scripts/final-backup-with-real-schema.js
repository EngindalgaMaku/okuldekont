#!/usr/bin/env node

/**
 * =================================================================
 * SON HALƒ∞ - GER√áEK SCHEMA Bƒ∞LGƒ∞LERƒ∞YLE BACKUP SCRƒ∞PTƒ∞
 * =================================================================
 * RPC fonksiyonlarƒ±, ger√ßek triggers, indexes ve policies ile
 * =================================================================
 */

const fs = require('fs');
const path = require('path');
const { createClient } = require('@supabase/supabase-js');
require('dotenv').config({ path: '.env.local' });

// Renk kodlarƒ±
const colors = {
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    cyan: '\x1b[36m',
    reset: '\x1b[0m'
};

function log(color, message) {
    console.log(`${colors[color]}${message}${colors.reset}`);
}

async function main() {
    log('blue', '='.repeat(65));
    log('blue', '    SON HALƒ∞ - GER√áEK SCHEMA Bƒ∞LGƒ∞LERƒ∞YLE BACKUP SCRƒ∞PTƒ∞');
    log('blue', '='.repeat(65));

    // Environment variables kontrol
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

    if (!supabaseUrl || !supabaseKey) {
        log('red', '‚ùå .env.local dosyasƒ±nda gerekli deƒüi≈ükenler eksik!');
        log('yellow', 'Gerekli deƒüi≈ükenler:');
        log('yellow', '  NEXT_PUBLIC_SUPABASE_URL');
        log('yellow', '  SUPABASE_SERVICE_ROLE_KEY');
        process.exit(1);
    }

    // Supabase client olu≈ütur
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Backup klas√∂r√º olu≈ütur
    const backupDir = './database_backups';
    if (!fs.existsSync(backupDir)) {
        fs.mkdirSync(backupDir, { recursive: true });
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0] + '_' + 
                     new Date().toISOString().replace(/[:.]/g, '-').split('T')[1].split('-')[0];

    log('yellow', `üìÅ Yedek klas√∂r√º: ${backupDir}`);

    try {
        // Tablo verilerini yedekle
        await backupTables(supabase, backupDir, timestamp);
        
        // RPC fonksiyonlarƒ±nƒ± yedekle
        await backupRpcFunctions(supabase, backupDir, timestamp);

        // Ger√ßek schema bilgilerini yedekle
        await backupRealSchema(supabase, backupDir, timestamp);

        // Restore talimatlarƒ± olu≈ütur
        createRestoreInstructions(backupDir, timestamp);

        log('green', '='.repeat(65));
        log('green', 'üéâ GER√áEK SCHEMA Bƒ∞LGƒ∞LERƒ∞YLE BACKUP TAMAMLANDI!');
        log('green', '='.repeat(65));
        log('yellow', `üìÅ Yedek konumu: ${backupDir}`);
        log('yellow', `üìÖ Yedek tarihi: ${timestamp}`);

    } catch (error) {
        log('red', `‚ùå Hata: ${error.message}`);
        process.exit(1);
    }
}

async function backupTables(supabase, backupDir, timestamp) {
    const backupData = {};
    
    // Bilinen tablolarƒ± manuel listele
    const tableList = [
        'admin_kullanicilar',
        'alanlar', 
        'belgeler',
        'dekontlar',
        'gorev_belgeleri',
        'isletmeler',
        'isletme_giris_denemeleri',
        'notifications',
        'ogretmenler',
        'ogretmen_giris_denemeleri',
        'siniflar',
        'system_settings'
    ];
    
    log('blue', `üìä ${tableList.length} tablo yedekleniyor...`);

    for (const tableName of tableList) {
        try {
            log('yellow', `  üìã ${tableName} tablosu yedekleniyor...`);
            
            const { data, error } = await supabase
                .from(tableName)
                .select('*');

            if (error) {
                log('red', `    ‚ùå ${tableName} hatasƒ±: ${error.message}`);
                continue;
            }

            backupData[tableName] = {
                table_name: tableName,
                row_count: data ? data.length : 0,
                data: data || []
            };

            log('green', `    ‚úÖ ${tableName}: ${data ? data.length : 0} kayƒ±t`);

        } catch (error) {
            log('red', `    ‚ùå ${tableName} hatasƒ±: ${error.message}`);
        }
    }

    // JSON olarak kaydet
    const dataBackupFile = path.join(backupDir, `data_backup_${timestamp}.json`);
    fs.writeFileSync(dataBackupFile, JSON.stringify(backupData, null, 2));
    log('green', `‚úÖ Veri yedeƒüi tamamlandƒ±: ${dataBackupFile}`);

    // SQL INSERT formatƒ±nda kaydet
    const sqlBackupFile = path.join(backupDir, `data_backup_${timestamp}.sql`);
    let sqlContent = `-- Supabase Veri Yedeƒüi\n-- Tarih: ${new Date().toISOString()}\n\n`;
    
    for (const [tableName, tableData] of Object.entries(backupData)) {
        if (tableData.data && tableData.data.length > 0) {
            sqlContent += `-- ${tableName} tablosu (${tableData.row_count} kayƒ±t)\n`;
            sqlContent += `TRUNCATE ${tableName} CASCADE;\n`;
            
            // INSERT statements olu≈ütur
            for (const row of tableData.data) {
                const columns = Object.keys(row).join(', ');
                const values = Object.values(row).map(val => {
                    if (val === null) return 'NULL';
                    if (typeof val === 'string') return `'${val.replace(/'/g, "''")}'`;
                    if (typeof val === 'boolean') return val;
                    if (typeof val === 'object') return `'${JSON.stringify(val).replace(/'/g, "''")}'`;
                    return val;
                }).join(', ');
                
                sqlContent += `INSERT INTO ${tableName} (${columns}) VALUES (${values});\n`;
            }
            sqlContent += '\n';
        }
    }

    fs.writeFileSync(sqlBackupFile, sqlContent);
    log('green', `‚úÖ SQL yedeƒüi tamamlandƒ±: ${sqlBackupFile}`);
}

async function backupRpcFunctions(supabase, backupDir, timestamp) {
    log('blue', 'üîß RPC Fonksiyonlarƒ± yedekleniyor...');
    
    // Test edilecek RPC fonksiyonlarƒ±
    const knownRpcFunctions = [
        'get_admin_users',
        'create_admin_user', 
        'update_admin_user',
        'delete_admin_user',
        'is_user_admin',
        'get_system_setting',
        'update_system_setting',
        'check_isletme_pin_giris',
        'check_ogretmen_pin_giris',
        'get_gorev_belgeleri_detayli',
        'exec_sql',
        'get_schema_triggers',
        'get_schema_indexes',
        'get_schema_policies'
    ];
    
    const rpcBackupData = {
        timestamp: new Date().toISOString(),
        total_functions: 0,
        working_functions: [],
        available_functions: [],
        function_details: {}
    };

    log('yellow', `  üîç ${knownRpcFunctions.length} RPC fonksiyonu test ediliyor...`);

    for (const funcName of knownRpcFunctions) {
        try {
            let result;
            let status = 'unknown';
            
            // Her fonksiyon i√ßin test parametreleri
            switch(funcName) {
                case 'get_admin_users':
                case 'get_schema_triggers':
                case 'get_schema_indexes':
                case 'get_schema_policies':
                    result = await supabase.rpc(funcName);
                    status = result.error ? 'available' : 'working';
                    break;
                case 'get_system_setting':
                    result = await supabase.rpc('get_system_setting', { p_setting_key: 'test' });
                    status = result.error ? 'available' : 'working';
                    break;
                case 'is_user_admin':
                    result = await supabase.rpc('is_user_admin', { p_user_id: '00000000-0000-0000-0000-000000000000' });
                    status = result.error ? 'available' : 'working';
                    break;
                default:
                    result = await supabase.rpc(funcName, {});
                    status = 'available';
            }
            
            if (result.error) {
                if (result.error.message.includes('function') && result.error.message.includes('does not exist')) {
                    log('red', `    ‚ùå ${funcName} - FONKSƒ∞YON BULUNAMADI`);
                    continue;
                } else {
                    log('cyan', `    ‚úÖ ${funcName} - MEVCUT`);
                    rpcBackupData.available_functions.push(funcName);
                    status = 'available';
                }
            } else {
                log('green', `    ‚úÖ ${funcName} - √áALI≈ûIYOR`);
                rpcBackupData.working_functions.push(funcName);
                status = 'working';
            }
            
            rpcBackupData.function_details[funcName] = {
                status: status,
                error: result.error ? result.error.message : null,
                test_date: new Date().toISOString()
            };
            
        } catch (error) {
            if (error.message.includes('function') && error.message.includes('does not exist')) {
                log('red', `    ‚ùå ${funcName} - FONKSƒ∞YON BULUNAMADI`);
            } else {
                log('cyan', `    ‚úÖ ${funcName} - MEVCUT (Hata: ${error.message.substring(0, 30)}...)`);
                rpcBackupData.available_functions.push(funcName);
                rpcBackupData.function_details[funcName] = {
                    status: 'available',
                    error: error.message,
                    test_date: new Date().toISOString()
                };
            }
        }
    }

    rpcBackupData.total_functions = rpcBackupData.working_functions.length + rpcBackupData.available_functions.length;

    // RPC backup dosyasƒ±nƒ± kaydet
    const rpcBackupFile = path.join(backupDir, `rpc_functions_backup_${timestamp}.json`);
    fs.writeFileSync(rpcBackupFile, JSON.stringify(rpcBackupData, null, 2));
    
    log('green', `‚úÖ RPC fonksiyon yedeƒüi tamamlandƒ±: ${rpcBackupFile}`);
    log('cyan', `  üìä Toplam ${rpcBackupData.total_functions} RPC fonksiyonu yedeklendi`);
    log('green', `  ‚úÖ ${rpcBackupData.working_functions.length} √ßalƒ±≈üƒ±r durumda`);
    log('cyan', `  ‚ö†Ô∏è ${rpcBackupData.available_functions.length} mevcut ama parametre uyumsuzluƒüu var`);
}

async function backupRealSchema(supabase, backupDir, timestamp) {
    try {
        log('blue', 'üìã GER√áEK schema bilgileri yedekleniyor...');

        const schemaInfo = {
            timestamp: new Date().toISOString(),
            real_data: true,
            triggers: [],
            indexes: [],
            policies: []
        };

        // Ger√ßek triggers'larƒ± al
        try {
            log('yellow', '  ‚ö° Ger√ßek triggers yedekleniyor...');
            const { data: triggers, error: triggerError } = await supabase.rpc('get_schema_triggers');
            
            if (!triggerError && triggers && Array.isArray(triggers)) {
                schemaInfo.triggers = triggers;
                log('green', `    ‚úÖ ${triggers.length} ger√ßek trigger veritabanƒ±ndan alƒ±ndƒ±`);
            } else {
                log('yellow', `    ‚ö†Ô∏è Trigger alma hatasƒ±: ${triggerError?.message || 'Bilinmeyen hata'}`);
                schemaInfo.triggers = [];
            }
        } catch (error) {
            log('yellow', `    ‚ö†Ô∏è Trigger exception: ${error.message}`);
            schemaInfo.triggers = [];
        }

        // Ger√ßek indexes'leri al
        try {
            log('yellow', '  üìä Ger√ßek indexes yedekleniyor...');
            const { data: indexes, error: indexError } = await supabase.rpc('get_schema_indexes');
            
            if (!indexError && indexes && Array.isArray(indexes)) {
                schemaInfo.indexes = indexes;
                log('green', `    ‚úÖ ${indexes.length} ger√ßek index veritabanƒ±ndan alƒ±ndƒ±`);
            } else {
                log('yellow', `    ‚ö†Ô∏è Index alma hatasƒ±: ${indexError?.message || 'Bilinmeyen hata'}`);
                schemaInfo.indexes = [];
            }
        } catch (error) {
            log('yellow', `    ‚ö†Ô∏è Index exception: ${error.message}`);
            schemaInfo.indexes = [];
        }

        // Ger√ßek policies'leri al
        try {
            log('yellow', '  üîí Ger√ßek RLS policies yedekleniyor...');
            const { data: policies, error: policyError } = await supabase.rpc('get_schema_policies');
            
            if (!policyError && policies && Array.isArray(policies)) {
                schemaInfo.policies = policies;
                log('green', `    ‚úÖ ${policies.length} ger√ßek RLS policy veritabanƒ±ndan alƒ±ndƒ±`);
            } else {
                log('yellow', `    ‚ö†Ô∏è Policy alma hatasƒ±: ${policyError?.message || 'Bilinmeyen hata'}`);
                schemaInfo.policies = [];
            }
        } catch (error) {
            log('yellow', `    ‚ö†Ô∏è Policy exception: ${error.message}`);
            schemaInfo.policies = [];
        }

        const schemaFile = path.join(backupDir, `real_schema_backup_${timestamp}.json`);
        fs.writeFileSync(schemaFile, JSON.stringify(schemaInfo, null, 2));
        log('green', `‚úÖ GER√áEK schema yedeƒüi tamamlandƒ±: ${schemaFile}`);

        // SQL format schema backup
        await createRealSchemaSQL(schemaInfo, backupDir, timestamp);

    } catch (error) {
        log('yellow', `‚ö†Ô∏è Schema yedekleme hatasƒ±: ${error.message}`);
    }
}

async function createRealSchemaSQL(schemaInfo, backupDir, timestamp) {
    try {
        log('yellow', '  üìÑ Ger√ßek Schema SQL dosyasƒ± olu≈üturuluyor...');
        
        let sqlContent = `-- Supabase GER√áEK Schema Yedeƒüi\n-- Tarih: ${new Date().toISOString()}\n\n`;
        
        // Triggers
        if (schemaInfo.triggers && schemaInfo.triggers.length > 0) {
            sqlContent += `-- =============================================================\n`;
            sqlContent += `-- GER√áEK TRIGGERS (${schemaInfo.triggers.length} adet)\n`;
            sqlContent += `-- =============================================================\n\n`;
            
            for (const trigger of schemaInfo.triggers) {
                sqlContent += `-- Trigger: ${trigger.trigger_name}\n`;
                sqlContent += `-- Tablo: ${trigger.table_name}\n`;
                sqlContent += `-- Fonksiyon: ${trigger.function_name}\n`;
                sqlContent += `-- Zamanlama: ${trigger.timing}\n`;
                sqlContent += `-- Olaylar: ${trigger.events}\n\n`;
            }
        }
        
        // Indexes
        if (schemaInfo.indexes && schemaInfo.indexes.length > 0) {
            sqlContent += `-- =============================================================\n`;
            sqlContent += `-- GER√áEK INDEXES (${schemaInfo.indexes.length} adet)\n`;
            sqlContent += `-- =============================================================\n\n`;
            
            for (const index of schemaInfo.indexes) {
                sqlContent += `-- Index: ${index.index_name} on ${index.table_name}\n`;
                sqlContent += `-- Unique: ${index.is_unique}, Primary: ${index.is_primary}\n`;
                if (index.definition) {
                    sqlContent += `${index.definition};\n`;
                }
                sqlContent += '\n';
            }
        }
        
        // Policies
        if (schemaInfo.policies && schemaInfo.policies.length > 0) {
            sqlContent += `-- =============================================================\n`;
            sqlContent += `-- GER√áEK RLS POLICIES (${schemaInfo.policies.length} adet)\n`;
            sqlContent += `-- =============================================================\n\n`;
            
            for (const policy of schemaInfo.policies) {
                sqlContent += `-- Policy: ${policy.policy_name} on ${policy.table_name}\n`;
                sqlContent += `-- Command: ${policy.command}\n\n`;
            }
        }
        
        const schemaFile = path.join(backupDir, `real_schema_backup_${timestamp}.sql`);
        fs.writeFileSync(schemaFile, sqlContent);
        log('green', `    ‚úÖ Ger√ßek Schema SQL dosyasƒ±: ${schemaFile}`);
        
    } catch (error) {
        log('yellow', `    ‚ö†Ô∏è Schema SQL olu≈üturma hatasƒ±: ${error.message}`);
    }
}

// Restore talimatlarƒ± olu≈ütur
function createRestoreInstructions(backupDir, timestamp) {
    const instructionsFile = path.join(backupDir, `restore_instructions_${timestamp}.txt`);
    const instructions = `
=================================================================
VERƒ∞TABANI GERƒ∞ Y√úKLEME TALƒ∞MATLARI (Ger√ßek Schema ile)
=================================================================
Tarih: ${new Date().toISOString()}
Yedek Dosyalarƒ±: ${timestamp}

YEDEK DOSYALARI:
- data_backup_${timestamp}.json              (Tablo verileri JSON)
- data_backup_${timestamp}.sql               (Tablo verileri SQL)
- rpc_functions_backup_${timestamp}.json     (RPC fonksiyonlarƒ±)
- real_schema_backup_${timestamp}.json       (GER√áEK Schema bilgileri JSON)
- real_schema_backup_${timestamp}.sql        (GER√áEK Schema bilgileri SQL)

√ñNEMLƒ∞: Bu backup ger√ßek veritabanƒ±ndan alƒ±nan schema bilgilerini i√ßerir!

1. TABLO VERƒ∞LERƒ∞Nƒ∞ GERƒ∞ Y√úKLEME:
   JSON formatƒ±ndan:
   node scripts/restore-from-json.js data_backup_${timestamp}.json
   
   SQL formatƒ±ndan:
   psql -h your-host -p 5432 -U postgres -d postgres -f data_backup_${timestamp}.sql

2. RPC FONKSƒ∞YONLARINI GERƒ∞ Y√úKLEME:
   - rpc_functions_backup_${timestamp}.json dosyasƒ±nƒ± a√ßƒ±n
   - √áalƒ±≈üan fonksiyonlarƒ± kontrol edin
   - scripts/ klas√∂r√ºndeki ilgili .sql dosyalarƒ±nƒ± √ßalƒ±≈ütƒ±rƒ±n

3. GER√áEK SCHEMA Bƒ∞LGƒ∞LERƒ∞Nƒ∞ GERƒ∞ Y√úKLEME:
   psql -h your-host -p 5432 -U postgres -d postgres -f real_schema_backup_${timestamp}.sql

UYARI:
- Bu backup GER√áEK veritabanƒ±ndan alƒ±nan schema bilgilerini i√ßerir
- Geri y√ºkleme i≈ülemi √∂ncesinde mevcut verileri yedekleyin
- RPC fonksiyonlarƒ± doƒüru parametrelerle test edin

=================================================================
`;

    fs.writeFileSync(instructionsFile, instructions);
    log('green', `üìã Restore talimatlarƒ± olu≈üturuldu: ${instructionsFile}`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = { main };